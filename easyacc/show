#!/usr/bin/python
#
import math
import sys
import copy
import datetime
import subprocess

def parse(s):
	val = s.split('.')
	value = abs(int(val[0])) * 100
	if len(val) > 1:
		if len(val[1]) == 1:
			val[1] += '0'
		value += int(val[1])

	return value

def is_number(s):
	try:
		float(s)
		return True
	except ValueError:
		return False

def fmt(bal, diff = False, pad = False):
	if diff:
		if bal == 0:
			s = '~'
		else:
			s = '%+.2f' % (float(bal)/100)
	else:
		s = '%.2f' % (float(bal)/100)

	l = len(s)
	if sys.stdout.isatty():
		if bal > 0:
			s = '\033[32m%s\033[0m' % s
		elif bal < 0:
			s = '\033[31m%s\033[0m' % s
	if l < 7:
		pad = '.' if pad else ' '
		s = pad * (6-l) + ' ' + s

	return s

def mod_acc(acc, amt):
	if acc in vaccs:
		raise Exception('illegal modification of virtual account "' + acc + '"')
	balances[acc] += amt

def prune_unchanged():
	keep = []
	
	for o in order:
		for i in range(num):
			if o not in log_bal[i] or log_bal[i][o] != log_bal[0][o]:
				keep.append(o)
				break
	return keep

def display_trans():
	for b in (True,False):
		for o in order:
			if (o in vaccs) ^ b:
				s = '*' if not b else ''
				print '%-10s' % (o+s),

				# first
				if o in log_bal[log_idx]:
					print '%s' % fmt(log_bal[log_idx][o]),
				else:
					print '%7s' % '*',

				# diffs
				for i in range(num-1):
					if o in log_bal[(log_idx + i + 1) % num] and o in log_bal[(log_idx + i) % num]:
						print '%s' % fmt(log_bal[(log_idx + i + 1) % num][o] - log_bal[(log_idx + i) % num][o], True),
					elif o in log_bal[(log_idx + i + 1) % num]:
						print '%s' % fmt(log_bal[(log_idx + i + 1) % num][o], True),
					else:
						print '%7s' % '*',
						
				# last
				if o in log_bal[(log_idx + num - 1) % num]:
					print '%s' % fmt(log_bal[(log_idx + num - 1) % num][o])
				else:
					print '%7s' % '*'
		if b:
			print
			

def display_balances():
	for b in (True,False):
		for o in order:
			if (o in vaccs) ^ b:
				s = '*' if not b else ''
				s += ' ' + '.' * (11 - len(o+s))
				print '     %s%s EUR' % (o+s, fmt(balances[o], False, True))
		if b:
			print

def update_vaccs():
	for acc in vaccs:
		balances[acc] = sum(map(lambda x: balances[x], vaccs[acc]))


def usage():
	print 'usage: %s SUBCOMMAND ...' % sys.argv[0]
	print '  subcommands:'
	print '    bal            show current balances for all accounts'
	print '    acc NAME       show transactions on account NAME'
	print '    trans [NUM]    show last NUM (default: 1) transactions'
	sys.exit(-1)


if sys.argv[-1] == '-v':
	f = subprocess.Popen(['svn', 'annotate', '-v', 'transactions.txt'], stdout=subprocess.PIPE).stdout
else:
	f = file('transactions.txt', 'r')

balances = {}
order = []
vaccs = {}

if len(sys.argv) < 2 or sys.argv[1] not in ('bal', 'acc', 'trans'):
	usage()

subcmd = sys.argv[1]

if subcmd == 'acc' and len(sys.argv) < 3:
	usage()
elif subcmd == 'acc':
	account = sys.argv[2]
	balances_before = {}

if subcmd == 'trans' and len(sys.argv) > 2:
	num = int(sys.argv[2]) + 1
else:
	num = 2

log_bal = [None] * num
log_cmt = [None] * num
log_bal[0] = copy.copy(balances)
log_idx = 1

for line in f:
	if sys.argv[-1] == '-v':
		date = line[18:28]
		line = line[63:]

	parts = line.strip().split(' ')
	if parts[0] == '#' or parts[0] == '':
		continue

	comment = ''
	expl = ''

	for i, v in enumerate(parts):
		if len(v) > 0 and v[0] == '#':
			if parts[i+1] == 'old':
				date = parts[i+2]
				i += 3
			comment = ' '.join(parts[i+1:])
			parts = parts[0:i]
			break

	parts = filter(lambda x: len(x) > 0, parts)

	if parts[0] == 'crt':
		balances[parts[1]] = 0
		order.append(parts[1])
		continue

	elif parts[0] == 'vcr':
		balances[parts[1]] = 0
		order.append(parts[1])
		vaccs[parts[1]] = parts[2:]
		expl = 'create virtual account'

	elif parts[0] == 'vad':
		vaccs[parts[1]].append(parts[2])
		expl = 'add %s to virtual account' % parts[2]

	elif parts[0] == 'cls':
		acc = parts[1]
		if not balances[acc] == 0 and not acc in vaccs:
			raise Exception('cannot close account ' + acc + ': non-zero balance')
		elif subcmd == 'bal':
			del balances[acc]
			order.remove(acc)
			for v in vaccs:
				if acc in vaccs[v]:
					vaccs[v].remove(acc)
			
		continue
	
	elif parts[0] == 'dep':
		acc = parts[1]
		amt = parse(parts[2])
		mod_acc(acc, amt)
		expl = 'deposition into %s' % acc

	elif parts[0] == 'wth':
		acc = parts[1]
		amt = parse(parts[2])
		mod_acc(acc, -amt)
		expl = 'withdrawal from %s' % acc

	elif parts[0] == 'xfr':
		from_acc = parts[1]
		to_acc = parts[2]
		amt = parse(parts[3])

		mod_acc(from_acc, -amt)
		mod_acc(to_acc, amt)
		expl = 'transfer from %s to %s' % (from_acc, to_acc)

	elif parts[0] == 'gxto' or parts[0] == 'gxfr':
		s = 1 if parts[0] == 'gxto' else -1
		target_acc = parts[1]
		if is_number(parts[2]):
			accs = parts[3:]
			amt = int(math.ceil(float(parse(parts[2])) / len(accs)))
			for a in accs:
				mod_acc(target_acc, amt * s)
				mod_acc(a, -amt * s)
		else:
			accamts = iter(parts[2:])
			for acc in accamts:
				amt = parse(accamts.next())
				mod_acc(target_acc, amt * s)
				mod_acc(acc, -amt * s)
		expl = 'compound transfer'

	else:
		raise Exception('unknown command: ' + parts[0])
		
	update_vaccs()

	log_bal[log_idx] = copy.copy(balances)
	log_cmt[log_idx] = comment
	log_idx = (log_idx + 1) % num

	if subcmd == 'acc':
		if account in balances:
			if account in balances_before:
				change = balances[account] - balances_before[account]
			else:
				change = balances[account]
			if change != 0:
				if len(comment) > 0 and sys.stdout.isatty():
					comment = '[\033[34m%s\033[0m]' % comment
				elif len(comment) > 0:
					comment = '[%s]' % comment

				if sys.argv[-1] == '-v':
					print '%s ' % date,
				print '%s  %s  %s' % (fmt(change), expl, comment)
			
		balances_before = copy.copy(balances)



if subcmd == 'trans':
	order = prune_unchanged()

	print 'account     before',
	for i in range(num-1):
		print '%7s' % ('(' + str(i+1) + ')'),
	print '  after'
	print '-' * (26 + (num-1)*8)

	display_trans()

	print
	print 'key:'
	for i in range(num-1):
		cmt = log_cmt[(log_idx + i + 1) % num]
		if cmt:
			print ' (%d) %s' % (i+1, cmt)
elif subcmd == 'bal':
	print 'Account balances as of ' + str(datetime.date.today())
	print '---------------------------------'
	display_balances()
	print '---------------------------------'
elif subcmd == 'acc':
	print '-' * 60
	if sys.argv[-1] == '-v':
		print ' ' * 11,
	print '%s  current balance' % fmt(balances[account])
